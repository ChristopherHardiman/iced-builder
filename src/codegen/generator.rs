//! Code generator for converting Layout AST to Rust/Iced code.
//!
//! Generates a `view` function that can be used in an Iced application.

use crate::model::{
    layout::{AlignmentSpec, LengthSpec, PaddingSpec, WidgetType},
    LayoutDocument, LayoutNode, ProjectConfig,
};
use std::fmt::Write;

/// Generate Rust code from a layout document.
pub fn generate_code(layout: &LayoutDocument, config: &ProjectConfig) -> String {
    tracing::info!(target: "iced_builder::codegen", layout_name = %layout.name, "Starting code generation");
    
    let mut output = String::new();

    // Header comment
    writeln!(output, "// Auto-generated by Iced Builder â€“ do not edit manually.").unwrap();
    writeln!(output, "// Regenerate by opening this project in Iced Builder.").unwrap();
    writeln!(output).unwrap();

    // Imports
    writeln!(output, "use iced::widget::{{").unwrap();
    writeln!(output, "    button, checkbox, column, container, pick_list, row,").unwrap();
    writeln!(output, "    scrollable, slider, stack, text, text_input, Space,").unwrap();
    writeln!(output, "}};").unwrap();
    writeln!(output, "use iced::{{Alignment, Color, Element, Length}};").unwrap();
    writeln!(output).unwrap();

    // Import user types
    writeln!(output, "use {};", config.message_type).unwrap();
    writeln!(output, "use {};", config.state_type).unwrap();
    writeln!(output).unwrap();

    // Extract type names from paths
    let message_name = config
        .message_type
        .split("::")
        .last()
        .unwrap_or("Message");
    let state_name = config.state_type.split("::").last().unwrap_or("AppState");

    // View function
    writeln!(
        output,
        "pub fn view(state: &{}) -> Element<{}> {{",
        state_name, message_name
    )
    .unwrap();

    // Generate the widget tree
    tracing::debug!(target: "iced_builder::codegen", "Generating widget tree");
    let widget_code = generate_node(&layout.root, 1);
    writeln!(output, "{}", widget_code).unwrap();

    writeln!(output, "}}").unwrap();

    output
}

/// Generate code for a single node.
fn generate_node(node: &LayoutNode, indent: usize) -> String {
    let indent_str = "    ".repeat(indent);

    match &node.widget {
        WidgetType::Column { children, attrs } => {
            generate_column(children, attrs, indent)
        }

        WidgetType::Row { children, attrs } => {
            generate_row(children, attrs, indent)
        }

        WidgetType::Container { child, attrs } => {
            let child_code = match child {
                Some(c) => generate_node(c, indent + 1),
                None => format!("{}text(\"\")", "    ".repeat(indent + 1)),
            };

            let mut code = format!("{}container(\n{}\n{})", indent_str, child_code, indent_str);
            code = append_container_attrs(&code, attrs, indent);
            // Add alignment for container
            if attrs.align_x != AlignmentSpec::Start {
                code = format!("{}.align_x({})", code, alignment_to_code(attrs.align_x));
            }
            if attrs.align_y != AlignmentSpec::Start {
                code = format!("{}.align_y({})", code, alignment_to_code(attrs.align_y));
            }
            format!("{}.into()", code)
        }

        WidgetType::Scrollable { child, attrs } => {
            let child_code = match child {
                Some(c) => generate_node(c, indent + 1),
                None => format!("{}text(\"\")", "    ".repeat(indent + 1)),
            };

            let mut code = format!("{}scrollable(\n{}\n{})", indent_str, child_code, indent_str);
            code = append_length_attrs(&code, attrs.width, attrs.height);
            format!("{}.into()", code)
        }

        WidgetType::Stack { children, attrs } => {
            generate_stack(children, attrs, indent)
        }

        WidgetType::Text { content, attrs } => {
            let mut code = format!("{}text(\"{}\")", indent_str, escape_string(content));
            if attrs.font_size != 16.0 {
                code = format!("{}.size({:.0})", code, attrs.font_size);
            }
            if let Some(color) = attrs.color {
                code = format!(
                    "{}.color(Color::from_rgba({:.2}, {:.2}, {:.2}, {:.2}))",
                    code, color[0], color[1], color[2], color[3]
                );
            }
            format!("{}.into()", code)
        }

        WidgetType::Button {
            label,
            message_stub,
            attrs,
        } => {
            let mut code = format!(
                "{}button(text(\"{}\")).on_press(Message::{})",
                indent_str,
                escape_string(label),
                message_stub
            );
            code = append_length_attrs(&code, attrs.width, attrs.height);
            format!("{}.into()", code)
        }

        WidgetType::TextInput {
            placeholder,
            value_binding,
            message_stub,
            attrs,
        } => {
            let mut code = format!(
                "{}text_input(\"{}\", &state.{}).on_input(Message::{})",
                indent_str,
                escape_string(placeholder),
                value_binding,
                message_stub
            );
            if attrs.width != LengthSpec::Shrink {
                code = format!("{}.width({})", code, length_to_code(attrs.width));
            }
            format!("{}.into()", code)
        }

        WidgetType::Checkbox {
            label,
            checked_binding,
            message_stub,
            ..
        } => {
            format!(
                "{}checkbox(\"{}\", state.{}).on_toggle(Message::{}).into()",
                indent_str,
                escape_string(label),
                checked_binding,
                message_stub
            )
        }

        WidgetType::Slider {
            min,
            max,
            value_binding,
            message_stub,
            attrs,
        } => {
            let mut code = format!(
                "{}slider({:.1}..={:.1}, state.{}, Message::{})",
                indent_str, min, max, value_binding, message_stub
            );
            if attrs.width != LengthSpec::Fill {
                code = format!("{}.width({})", code, length_to_code(attrs.width));
            }
            format!("{}.into()", code)
        }

        WidgetType::PickList {
            options,
            selected_binding,
            message_stub,
            ..
        } => {
            let options_code: Vec<String> = options.iter().map(|o| format!("\"{}\"", o)).collect();
            format!(
                "{}pick_list(&[{}][..], state.{}.as_ref(), Message::{}).into()",
                indent_str,
                options_code.join(", "),
                selected_binding,
                message_stub
            )
        }

        WidgetType::Space { width, height } => {
            format!(
                "{}Space::new({}, {}).into()",
                indent_str,
                length_to_code(*width),
                length_to_code(*height)
            )
        }
    }
}

/// Generate code for column containers with align_x support.
fn generate_column(
    children: &[LayoutNode],
    attrs: &crate::model::layout::ContainerAttrs,
    indent: usize,
) -> String {
    let indent_str = "    ".repeat(indent);

    let mut code = if children.is_empty() {
        format!("{}column![]", indent_str)
    } else {
        let mut c = format!("{}column![\n", indent_str);
        for (i, child) in children.iter().enumerate() {
            let child_code = generate_node(child, indent + 1);
            c.push_str(&child_code);
            if i < children.len() - 1 {
                c.push_str(",\n");
            } else {
                c.push('\n');
            }
        }
        c.push_str(&format!("{}]", indent_str));
        c
    };

    code = append_container_attrs(&code, attrs, indent);
    
    // Column uses align_x for horizontal alignment of children
    if attrs.align_x != AlignmentSpec::Start {
        code = format!("{}.align_x({})", code, alignment_to_code(attrs.align_x));
    }
    
    format!("{}.into()", code)
}

/// Generate code for row containers with align_y support.
fn generate_row(
    children: &[LayoutNode],
    attrs: &crate::model::layout::ContainerAttrs,
    indent: usize,
) -> String {
    let indent_str = "    ".repeat(indent);

    let mut code = if children.is_empty() {
        format!("{}row![]", indent_str)
    } else {
        let mut c = format!("{}row![\n", indent_str);
        for (i, child) in children.iter().enumerate() {
            let child_code = generate_node(child, indent + 1);
            c.push_str(&child_code);
            if i < children.len() - 1 {
                c.push_str(",\n");
            } else {
                c.push('\n');
            }
        }
        c.push_str(&format!("{}]", indent_str));
        c
    };

    code = append_container_attrs(&code, attrs, indent);
    
    // Row uses align_y for vertical alignment of children
    if attrs.align_y != AlignmentSpec::Start {
        code = format!("{}.align_y({})", code, alignment_to_code(attrs.align_y));
    }
    
    format!("{}.into()", code)
}

/// Generate code for stack containers.
fn generate_stack(
    children: &[LayoutNode],
    attrs: &crate::model::layout::ContainerAttrs,
    indent: usize,
) -> String {
    let indent_str = "    ".repeat(indent);

    let mut code = if children.is_empty() {
        format!("{}stack![]", indent_str)
    } else {
        let mut c = format!("{}stack![\n", indent_str);
        for (i, child) in children.iter().enumerate() {
            let child_code = generate_node(child, indent + 1);
            c.push_str(&child_code);
            if i < children.len() - 1 {
                c.push_str(",\n");
            } else {
                c.push('\n');
            }
        }
        c.push_str(&format!("{}]", indent_str));
        c
    };

    code = append_length_attrs(&code, attrs.width, attrs.height);
    
    format!("{}.into()", code)
}

/// Append container attributes to code.
fn append_container_attrs(
    code: &str,
    attrs: &crate::model::layout::ContainerAttrs,
    _indent: usize,
) -> String {
    let mut result = code.to_string();

    if attrs.padding != PaddingSpec::ZERO {
        if attrs.padding.top == attrs.padding.right
            && attrs.padding.right == attrs.padding.bottom
            && attrs.padding.bottom == attrs.padding.left
        {
            result = format!("{}.padding({:.0})", result, attrs.padding.top);
        } else {
            result = format!(
                "{}.padding([{:.0}, {:.0}, {:.0}, {:.0}])",
                result, attrs.padding.top, attrs.padding.right, attrs.padding.bottom, attrs.padding.left
            );
        }
    }

    if attrs.spacing != 0.0 {
        result = format!("{}.spacing({:.0})", result, attrs.spacing);
    }

    result = append_length_attrs(&result, attrs.width, attrs.height);

    result
}

/// Append width/height attributes to code.
fn append_length_attrs(code: &str, width: LengthSpec, height: LengthSpec) -> String {
    let mut result = code.to_string();

    if width != LengthSpec::Shrink {
        result = format!("{}.width({})", result, length_to_code(width));
    }

    if height != LengthSpec::Shrink {
        result = format!("{}.height({})", result, length_to_code(height));
    }

    result
}

/// Convert a LengthSpec to Rust code.
fn length_to_code(length: LengthSpec) -> String {
    match length {
        LengthSpec::Fill => "Length::Fill".to_string(),
        LengthSpec::Shrink => "Length::Shrink".to_string(),
        LengthSpec::FillPortion(p) => format!("Length::FillPortion({})", p),
        LengthSpec::Fixed(f) => format!("Length::Fixed({:.1})", f),
    }
}

/// Convert an AlignmentSpec to Rust code.
fn alignment_to_code(alignment: AlignmentSpec) -> String {
    match alignment {
        AlignmentSpec::Start => "Alignment::Start".to_string(),
        AlignmentSpec::Center => "Alignment::Center".to_string(),
        AlignmentSpec::End => "Alignment::End".to_string(),
    }
}

/// Escape a string for use in Rust code.
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::layout::{ContainerAttrs, TextAttrs};

    #[test]
    fn test_escape_string() {
        assert_eq!(escape_string("hello"), "hello");
        assert_eq!(escape_string("hello\"world"), "hello\\\"world");
        assert_eq!(escape_string("line1\nline2"), "line1\\nline2");
    }

    #[test]
    fn test_length_to_code() {
        assert_eq!(length_to_code(LengthSpec::Fill), "Length::Fill");
        assert_eq!(length_to_code(LengthSpec::Shrink), "Length::Shrink");
        assert_eq!(length_to_code(LengthSpec::FillPortion(2)), "Length::FillPortion(2)");
        assert_eq!(length_to_code(LengthSpec::Fixed(100.0)), "Length::Fixed(100.0)");
    }

    #[test]
    fn test_alignment_to_code() {
        assert_eq!(alignment_to_code(AlignmentSpec::Start), "Alignment::Start");
        assert_eq!(alignment_to_code(AlignmentSpec::Center), "Alignment::Center");
        assert_eq!(alignment_to_code(AlignmentSpec::End), "Alignment::End");
    }

    #[test]
    fn test_generate_column_with_alignment() {
        let mut attrs = ContainerAttrs::default();
        attrs.align_x = AlignmentSpec::Center;
        
        let code = generate_column(&[], &attrs, 1);
        assert!(code.contains("column![]"));
        assert!(code.contains(".align_x(Alignment::Center)"));
        assert!(code.contains(".into()"));
    }

    #[test]
    fn test_generate_row_with_alignment() {
        let mut attrs = ContainerAttrs::default();
        attrs.align_y = AlignmentSpec::End;
        
        let code = generate_row(&[], &attrs, 1);
        assert!(code.contains("row![]"));
        assert!(code.contains(".align_y(Alignment::End)"));
        assert!(code.contains(".into()"));
    }

    #[test]
    fn test_generate_stack() {
        let children = vec![
            LayoutNode::new(WidgetType::Text {
                content: "Layer 1".to_string(),
                attrs: TextAttrs::default(),
            }),
            LayoutNode::new(WidgetType::Text {
                content: "Layer 2".to_string(),
                attrs: TextAttrs::default(),
            }),
        ];
        
        let attrs = ContainerAttrs::default();
        let code = generate_stack(&children, &attrs, 1);
        
        assert!(code.contains("stack!["));
        assert!(code.contains("Layer 1"));
        assert!(code.contains("Layer 2"));
        assert!(code.contains(".into()"));
    }

    #[test]
    fn test_generate_code_includes_stack_import() {
        let layout = LayoutDocument::default();
        let config = ProjectConfig::default();
        
        let code = generate_code(&layout, &config);
        
        assert!(code.contains("stack"));
        assert!(code.contains("use iced::widget::{"));
    }
}
